<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thanksgiving Fantasy Football</title>
    <link href="https://fonts.googleapis.com/css2?family=Teko:wght@500;700&family=Work+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --burnt-orange: #D2691E;
            --deep-brown: #3E2723;
            --cream: #FFF8DC;
            --forest-green: #2E5D3F;
            --gold: #FFB300;
            --red: #C62828;
        }

        body {
            font-family: 'Work Sans', sans-serif;
            background: linear-gradient(135deg, #1a1410 0%, #2d1f15 100%);
            color: var(--cream);
            min-height: 100vh;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(255, 248, 220, 0.02) 2px,
                    rgba(255, 248, 220, 0.02) 4px
                );
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            padding: 40px 20px;
            background: linear-gradient(135deg, var(--burnt-orange) 0%, var(--deep-brown) 100%);
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            border: 3px solid var(--gold);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: 'ü¶É';
            position: absolute;
            top: -20px;
            right: -20px;
            font-size: 120px;
            opacity: 0.15;
            transform: rotate(-15deg);
        }

        header::after {
            content: 'üèà';
            position: absolute;
            bottom: -30px;
            left: -30px;
            font-size: 120px;
            opacity: 0.15;
            transform: rotate(25deg);
        }

        h1 {
            font-family: 'Teko', sans-serif;
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 700;
            letter-spacing: 3px;
            text-transform: uppercase;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
            margin-bottom: 10px;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        button {
            font-family: 'Teko', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            padding: 15px 35px;
            background: linear-gradient(135deg, var(--forest-green) 0%, var(--burnt-orange) 100%);
            color: var(--cream);
            border: 3px solid var(--gold);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 179, 0, 0.4);
            border-color: var(--cream);
        }

        button:active {
            transform: translateY(-1px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .fetch-live-btn {
            background: linear-gradient(135deg, var(--gold) 0%, var(--burnt-orange) 100%);
            border-color: var(--cream);
            font-size: 1.4rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 4px 15px rgba(255, 179, 0, 0.4); }
            50% { box-shadow: 0 4px 25px rgba(255, 179, 0, 0.8); }
        }

        .standings {
            background: rgba(62, 39, 35, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 40px;
            border: 2px solid var(--burnt-orange);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
        }

        .standings h2 {
            font-family: 'Teko', sans-serif;
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 25px;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .standings-grid {
            display: grid;
            gap: 15px;
        }

        .standing-item {
            display: grid;
            grid-template-columns: 60px 1fr 100px;
            align-items: center;
            background: rgba(255, 248, 220, 0.05);
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 5px solid var(--burnt-orange);
            transition: all 0.3s ease;
        }

        .standing-item:hover {
            background: rgba(255, 248, 220, 0.1);
            border-left-color: var(--gold);
            transform: translateX(5px);
        }

        .standing-item.first {
            background: linear-gradient(90deg, rgba(255, 179, 0, 0.2) 0%, rgba(255, 248, 220, 0.05) 100%);
            border-left-color: var(--gold);
            border-width: 6px;
        }

        .rank {
            font-family: 'Teko', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--gold);
        }

        .team-name {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--cream);
        }

        .points {
            font-family: 'Teko', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            text-align: right;
            color: var(--forest-green);
        }

        .standing-item.first .points {
            color: var(--gold);
        }

        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .team-card {
            background: rgba(62, 39, 35, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 2px solid var(--burnt-orange);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        .team-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(210, 105, 30, 0.3);
            border-color: var(--gold);
        }

        .team-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--burnt-orange);
        }

        .team-card h3 {
            font-family: 'Teko', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .team-total {
            font-family: 'Teko', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            color: var(--forest-green);
            background: rgba(255, 248, 220, 0.1);
            padding: 5px 15px;
            border-radius: 8px;
        }

        .player {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 15px;
            padding: 12px 15px;
            background: rgba(255, 248, 220, 0.05);
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .player:hover {
            background: rgba(255, 248, 220, 0.1);
            border-left-color: var(--burnt-orange);
        }

        .player-name {
            font-weight: 700;
            color: var(--cream);
        }

        .player-team {
            color: var(--gold);
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .player-points {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .player-points input {
            width: 70px;
            padding: 5px 10px;
            background: rgba(255, 248, 220, 0.1);
            border: 2px solid var(--burnt-orange);
            border-radius: 5px;
            color: var(--cream);
            font-family: 'Teko', sans-serif;
            font-size: 1.3rem;
            font-weight: 700;
            text-align: center;
        }

        .player-points input:focus {
            outline: none;
            border-color: var(--gold);
            background: rgba(255, 248, 220, 0.15);
        }

        .player-score {
            font-family: 'Teko', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--forest-green);
            min-width: 50px;
            text-align: right;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, var(--deep-brown) 0%, #1a1410 100%);
            border: 3px solid var(--gold);
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
        }

        .modal-content h2 {
            font-family: 'Teko', sans-serif;
            font-size: 2.5rem;
            color: var(--gold);
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        .modal-content textarea {
            width: 100%;
            height: 300px;
            background: rgba(255, 248, 220, 0.1);
            border: 2px solid var(--burnt-orange);
            border-radius: 10px;
            color: var(--cream);
            font-family: 'Work Sans', sans-serif;
            font-size: 0.9rem;
            padding: 15px;
            margin-bottom: 20px;
        }

        .modal-content textarea:focus {
            outline: none;
            border-color: var(--gold);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .last-update {
            text-align: center;
            margin-top: 40px;
            color: var(--burnt-orange);
            font-size: 0.9rem;
            font-style: italic;
        }

        .status-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--forest-green);
            color: var(--cream);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid var(--gold);
            font-weight: 700;
            z-index: 2000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .status-message.show {
            transform: translateY(0);
            opacity: 1;
        }

        .status-message.error {
            background: var(--red);
        }

        @media (max-width: 768px) {
            .teams-grid {
                grid-template-columns: 1fr;
            }

            .standing-item {
                grid-template-columns: 50px 1fr 80px;
                padding: 12px 15px;
            }

            h1 {
                font-size: 2.5rem;
            }

            .controls {
                flex-direction: column;
            }

            button {
                width: 100%;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .team-card {
            animation: slideIn 0.5s ease backwards;
        }

        .team-card:nth-child(1) { animation-delay: 0.1s; }
        .team-card:nth-child(2) { animation-delay: 0.2s; }
        .team-card:nth-child(3) { animation-delay: 0.3s; }
        .team-card:nth-child(4) { animation-delay: 0.4s; }
        .team-card:nth-child(5) { animation-delay: 0.5s; }
        .team-card:nth-child(6) { animation-delay: 0.6s; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ü¶É Thanksgiving Fantasy Football üèà</h1>
            <div class="subtitle">Live Scoring Dashboard</div>
        </header>

        <div class="controls">
            <button class="fetch-live-btn" onclick="fetchLiveScores()">‚ö° Fetch Live Scores from ESPN</button>
            <button id="autoFetchBtn" onclick="toggleAutoFetch()">ü§ñ Auto-Fetch: OFF</button>
            <button onclick="loadTeamsModal()">üì• Load Teams (JSON)</button>
            <button onclick="addTeam()">‚ûï Add Team</button>
            <button onclick="saveData()">üíæ Save Progress</button>
            <button onclick="resetData()">üîÑ Reset All</button>
        </div>

        <div class="standings">
            <h2>üèÜ Live Standings</h2>
            <div class="standings-grid" id="standingsGrid"></div>
        </div>

        <div class="teams-grid" id="teamsGrid"></div>

        <div class="last-update" id="lastUpdate"></div>
    </div>

    <div class="status-message" id="statusMessage"></div>

    <div class="modal" id="loadModal">
        <div class="modal-content">
            <h2>Load Teams from JSON</h2>
            <p style="margin-bottom: 15px; opacity: 0.8;">Paste the JSON data from your Discord bot export:</p>
            <textarea id="jsonInput" placeholder='[{"team_name": "Team 1", "players": [{"name": "Player Name", "team": "NFL Team"}]}]'></textarea>
            <div class="modal-buttons">
                <button onclick="closeModal()">Cancel</button>
                <button onclick="loadTeamsFromJSON()">Load Teams</button>
            </div>
        </div>
    </div>
	<script>
	// This tells the frontend where your Worker API lives
	window.APP_API_BASE = '/';
	</script>


    <script>
        let teamsData = [];
        const STORAGE_KEY = 'thanksgiving_fantasy_data';
        const API_BASE = window.APP_API_BASE || '';
        let useRemoteSync = true;
        let eventSource;
        let autoFetchEnabled = false;
        let autoFetchInterval = null;
        let consecutiveErrors = 0;
        const MAX_CONSECUTIVE_ERRORS = 3;
        const BASE_FETCH_INTERVAL = 120000; // 2 minutes in milliseconds
        
        // Game time windows (ET timezone)
        const GAME_WINDOWS = [
            // Thursday games
            { day: 4, startHour: 12, startMinute: 30, endHour: 23, endMinute: 0 },
            // Friday game
            { day: 5, startHour: 15, startMinute: 0, endHour: 18, endMinute: 30 }
        ];

        // Initialize
        async function init() {
            await loadData();
            if (teamsData.length === 0) {
                // Sample data for testing
                teamsData = [
                    {
                        team_name: "Sample Team 1",
                        players: [
                            { name: "Player 1", team: "DAL", points: 0 },
                            { name: "Player 2", team: "DET", points: 0 }
                        ]
                    },
                    {
                        team_name: "Sample Team 2",
                        players: [
                            { name: "Player 3", team: "GB", points: 0 },
                            { name: "Player 4", team: "MIA", points: 0 }
                        ]
                    }
                ];
            }
            startLiveUpdates();
            render();
            
            // Check if we should auto-enable fetching
            if (isWithinGameWindow()) {
                console.log('Currently within game window - auto-fetch available');
            }
        }

        function isWithinGameWindow() {
            const now = new Date();
            // Convert to ET (UTC-5 or UTC-4 depending on DST)
            const etOffset = -5 * 60; // Assuming EST
            const etTime = new Date(now.getTime() + (etOffset + now.getTimezoneOffset()) * 60000);
            
            const currentDay = etTime.getDay();
            const currentHour = etTime.getHours();
            const currentMinute = etTime.getMinutes();
            const currentTimeInMinutes = currentHour * 60 + currentMinute;
            
            for (const window of GAME_WINDOWS) {
                if (currentDay === window.day) {
                    const windowStart = window.startHour * 60 + window.startMinute;
                    const windowEnd = window.endHour * 60 + window.endMinute;
                    
                    if (currentTimeInMinutes >= windowStart && currentTimeInMinutes <= windowEnd) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        function toggleAutoFetch() {
            if (autoFetchEnabled) {
                // Turn OFF
                autoFetchEnabled = false;
                if (autoFetchInterval) {
                    clearInterval(autoFetchInterval);
                    autoFetchInterval = null;
                }
                updateAutoFetchButton();
                showStatus('üî¥ Auto-fetch disabled', false);
            } else {
                // Turn ON - but check if within game window
                if (!isWithinGameWindow()) {
                    const confirm = window.confirm(
                        '‚ö†Ô∏è Games are not currently live.\n\n' +
                        'Auto-fetch works best during:\n' +
                        '‚Ä¢ Thursday: 12:30 PM - 11:00 PM ET\n' +
                        '‚Ä¢ Friday: 3:00 PM - 6:30 PM ET\n\n' +
                        'Enable anyway?'
                    );
                    if (!confirm) return;
                }
                
                autoFetchEnabled = true;
                consecutiveErrors = 0;
                startAutoFetch();
                updateAutoFetchButton();
                showStatus('üü¢ Auto-fetch enabled (every 2 minutes)', false);
            }
        }

        function updateAutoFetchButton() {
            const btn = document.getElementById('autoFetchBtn');
            if (autoFetchEnabled) {
                btn.textContent = 'üü¢ Auto-Fetch: ON';
                btn.style.background = 'linear-gradient(135deg, var(--forest-green) 0%, #1a6b3a 100%)';
            } else {
                btn.textContent = 'üî¥ Auto-Fetch: OFF';
                btn.style.background = 'linear-gradient(135deg, var(--forest-green) 0%, var(--burnt-orange) 100%)';
            }
        }

        function startAutoFetch() {
            if (autoFetchInterval) {
                clearInterval(autoFetchInterval);
            }
            
            // Fetch immediately
            fetchLiveScoresAuto();
            
            // Then every 2 minutes
            autoFetchInterval = setInterval(() => {
                if (!isWithinGameWindow() && consecutiveErrors === 0) {
                    console.log('Outside game window, pausing auto-fetch');
                    showStatus('‚è∏Ô∏è Auto-fetch paused (outside game window)', false);
                    return;
                }
                
                fetchLiveScoresAuto();
            }, BASE_FETCH_INTERVAL);
        }

        async function fetchLiveScoresAuto() {
            try {
                const response = await fetch(`${API_BASE}/api/live-scores`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch scores');
                }
                
                // Check if all games are final
                if (data.allGamesFinal) {
                    console.log('All games are final, stopping auto-fetch');
                    autoFetchEnabled = false;
                    if (autoFetchInterval) {
                        clearInterval(autoFetchInterval);
                        autoFetchInterval = null;
                    }
                    updateAutoFetchButton();
                    showStatus('‚úÖ All games final - auto-fetch stopped', false);
                    return;
                }
                
                let updatedCount = 0;
                
                // Update player points
                for (const team of teamsData) {
                    for (const player of team.players) {
                        const playerKey = `${player.name}|${player.team}`;
                        
                        if (data.players[playerKey]) {
                            const newPoints = data.players[playerKey].points || 0;
                            player.points = newPoints;
                            updatedCount++;
                        }
                    }
                }
                
                if (updatedCount > 0) {
                    render();
                    await saveData(false);
                    console.log(`Auto-updated ${updatedCount} players from ${data.gamesCount} games`);
                }
                
                // Reset error counter on success
                consecutiveErrors = 0;
                
            } catch (error) {
                console.error('Auto-fetch error:', error);
                consecutiveErrors++;
                
                if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
                    autoFetchEnabled = false;
                    if (autoFetchInterval) {
                        clearInterval(autoFetchInterval);
                        autoFetchInterval = null;
                    }
                    updateAutoFetchButton();
                    showStatus('‚ùå Auto-fetch stopped (too many errors). Click to retry.', true);
                }
            }
        }

        // NEW: Fetch live scores from ESPN via Cloudflare Worker
        async function fetchLiveScores() {
            showStatus('Fetching live scores from ESPN...', false);
            
            const fetchButton = event.target;
            fetchButton.disabled = true;
            fetchButton.textContent = '‚è≥ Fetching...';
            
            try {
                const response = await fetch(`${API_BASE}/api/live-scores`);
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to fetch scores');
                }
                
                let updatedCount = 0;
                
                // Update player points based on ESPN data
                for (const team of teamsData) {
                    for (const player of team.players) {
                        const playerKey = `${player.name}|${player.team}`;
                        
                        if (data.players[playerKey]) {
                            const newPoints = data.players[playerKey].points || 0;
                            player.points = newPoints;
                            updatedCount++;
                        }
                    }
                }
                
                render();
                await saveData(false);
                
                showStatus(`‚úÖ Updated ${updatedCount} players from ${data.gamesCount} games!`, false);
                
            } catch (error) {
                console.error('Error fetching live scores:', error);
                showStatus('‚ùå Failed to fetch scores. Try again or enter manually.', true);
            } finally {
                fetchButton.disabled = false;
                fetchButton.textContent = '‚ö° Fetch Live Scores from ESPN';
            }
        }

        function showStatus(message, isError) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message show' + (isError ? ' error' : '');
            
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 4000);
        }

        async function loadData() {
            if (!useRemoteSync) {
                loadFromStorage();
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/data`);
                if (!response.ok) throw new Error('Failed to fetch shared data');
                const payload = await response.json();
                teamsData = Array.isArray(payload.teams) ? payload.teams : [];
                updateLastUpdate(payload.updatedAt);
                localStorage.setItem(STORAGE_KEY, JSON.stringify(teamsData));
            } catch (error) {
                console.warn('Falling back to local storage, shared backend not reachable:', error);
                useRemoteSync = false;
                loadFromStorage();
            }
        }

        function loadFromStorage() {
            const stored = localStorage.getItem(STORAGE_KEY);
            if (stored) {
                try {
                    teamsData = JSON.parse(stored);
                    updateLastUpdate();
                } catch (e) {
                    console.error('Error loading data:', e);
                }
            }
        }

        async function saveData(showAlert = true) {
            if (useRemoteSync) {
                try {
                    const response = await fetch(`${API_BASE}/api/data`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ teams: teamsData })
                    });

                    if (!response.ok) throw new Error('Failed to save to shared backend');
                    const payload = await response.json();
                    updateLastUpdate(payload.updatedAt);
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(teamsData));
                    if (showAlert) alert('‚úÖ Progress saved for everyone!');
                    return;
                } catch (error) {
                    console.warn('Shared save failed, switching to local-only mode:', error);
                    useRemoteSync = false;
                }
            }

            localStorage.setItem(STORAGE_KEY, JSON.stringify(teamsData));
            updateLastUpdate();
            if (showAlert) alert('‚úÖ Progress saved locally. Shared backend not available.');
        }

        function updateLastUpdate(timestamp) {
            const date = timestamp ? new Date(timestamp) : new Date();
            document.getElementById('lastUpdate').textContent =
                `Last updated: ${date.toLocaleString()}`;
        }

        function render() {
            renderStandings();
            renderTeams();
            updateLastUpdate();
        }

        function renderStandings() {
            const standings = teamsData
                .map((team, index) => ({
                    ...team,
                    originalIndex: index,
                    total: team.players.reduce((sum, p) => sum + (parseFloat(p.points) || 0), 0)
                }))
                .sort((a, b) => b.total - a.total);

            const html = standings.map((team, rank) => `
                <div class="standing-item ${rank === 0 ? 'first' : ''}">
                    <div class="rank">#${rank + 1}</div>
                    <div class="team-name">${team.team_name}</div>
                    <div class="points">${team.total.toFixed(1)}</div>
                </div>
            `).join('');

            document.getElementById('standingsGrid').innerHTML = html;
        }

        function renderTeams() {
            const html = teamsData.map((team, teamIndex) => {
                const total = team.players.reduce((sum, p) => sum + (parseFloat(p.points) || 0), 0);
                
                const playersHtml = team.players.map((player, playerIndex) => `
                    <div class="player">
                        <div>
                            <div class="player-name">${player.name}</div>
                            <div class="player-team">${player.team}</div>
                        </div>
                        <div class="player-points">
                            <input 
                                type="number" 
                                step="0.1" 
                                value="${player.points || 0}" 
                                onchange="updatePlayerPoints(${teamIndex}, ${playerIndex}, this.value)"
                                placeholder="0.0"
                            />
                        </div>
                        <div class="player-score">${(parseFloat(player.points) || 0).toFixed(1)}</div>
                    </div>
                `).join('');

                return `
                    <div class="team-card">
                        <div class="team-header">
                            <h3>${team.team_name}</h3>
                            <div class="team-total">${total.toFixed(1)}</div>
                        </div>
                        <div class="players-list">
                            ${playersHtml}
                        </div>
                        <button onclick="addPlayerToTeam(${teamIndex})" style="width: 100%; margin-top: 15px;">
                            ‚ûï Add Player
                        </button>
                    </div>
                `;
            }).join('');

            document.getElementById('teamsGrid').innerHTML = html;
        }

        async function updatePlayerPoints(teamIndex, playerIndex, points) {
            teamsData[teamIndex].players[playerIndex].points = parseFloat(points) || 0;
            render();
            await saveData(false);
        }

        async function addTeam() {
            const teamName = prompt('Enter team name:');
            if (teamName) {
                teamsData.push({
                    team_name: teamName,
                    players: []
                });
                render();
                await saveData(false);
            }
        }

        async function addPlayerToTeam(teamIndex) {
            const playerName = prompt('Enter player name:');
            if (!playerName) return;

            const playerTeam = prompt('Enter NFL team (e.g., DAL, DET):');
            if (!playerTeam) return;

            teamsData[teamIndex].players.push({
                name: playerName,
                team: playerTeam,
                points: 0
            });
            render();
            await saveData(false);
        }

        function loadTeamsModal() {
            document.getElementById('loadModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('loadModal').classList.remove('active');
        }

        async function loadTeamsFromJSON() {
            const jsonText = document.getElementById('jsonInput').value;
            try {
                const parsed = JSON.parse(jsonText);
                
                // Convert format from Discord bot to our format
                teamsData = parsed.map(team => ({
                    team_name: team.team_name || team.name || 'Unnamed Team',
                    players: team.players.map(p => ({
                        name: p.name,
                        team: p.team,
                        points: 0
                    }))
                }));

                render();
                await saveData(false);
                closeModal();
                alert('‚úÖ Teams loaded successfully!');
            } catch (e) {
                alert('‚ùå Invalid JSON format. Please check your data and try again.');
                console.error('Error parsing JSON:', e);
            }
        }

        async function resetData() {
            if (confirm('‚ö†Ô∏è Are you sure you want to reset all data? This cannot be undone!')) {
                teamsData = [];
                localStorage.removeItem(STORAGE_KEY);
                render();
                await saveData(false);
                alert('‚úÖ All data has been reset!');
            }
        }

        function startLiveUpdates() {
            if (!useRemoteSync) return;

            try {
                eventSource = new EventSource(`${API_BASE}/api/stream`);
                eventSource.onmessage = (event) => {
                    try {
                        const payload = JSON.parse(event.data);
                        if (Array.isArray(payload.teams)) {
                            teamsData = payload.teams;
                            localStorage.setItem(STORAGE_KEY, JSON.stringify(teamsData));
                            render();
                            updateLastUpdate(payload.updatedAt);
                        }
                    } catch (error) {
                        console.error('Error parsing live update:', error);
                    }
                };

                eventSource.onerror = (error) => {
                    console.warn('Live updates unavailable, falling back to local-only mode.', error);
                    useRemoteSync = false;
                    eventSource.close();
                };
            } catch (error) {
                console.warn('Could not start live updates, continuing locally.', error);
                useRemoteSync = false;
            }
        }

        // Auto-save every 30 seconds
        setInterval(() => {
            if (teamsData.length > 0) {
                saveData(false);
            }
        }, 30000);

        // Initialize on load
        init();
    </script>
</body>
</html>
